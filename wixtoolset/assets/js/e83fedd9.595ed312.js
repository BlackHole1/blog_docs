"use strict";(self.webpackChunkwixweb=self.webpackChunkwixweb||[]).push([[35485],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>h});var n=r(67294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},u=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},f=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(r),f=i,h=c["".concat(s,".").concat(f)]||c[f]||d[f]||a;return r?n.createElement(h,o(o({ref:t},u),{},{components:r})):n.createElement(h,o({ref:t},u))}));function h(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<a;p++)o[p]=r[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}f.displayName="MDXCreateElement"},94893:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>p,toc:()=>c});r(67294);var n=r(3905);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))})),e}function o(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}const l={},s="How To: Specify source files",p={unversionedId:"howtos/general/specifying_source_files",id:"version-v3/howtos/general/specifying_source_files",title:"How To: Specify source files",description:"WiX provides three ways of identifying a setup package's payload - the files",source:"@site/versioned_docs/version-v3/howtos/general/specifying_source_files.md",sourceDirName:"howtos/general",slug:"/howtos/general/specifying_source_files",permalink:"/wixtoolset/docs/v3/howtos/general/specifying_source_files",draft:!1,editUrl:"https://github.com/wixtoolset/web/tree/master/src/Docusaurus/versioned_docs/version-v3/howtos/general/specifying_source_files.md",tags:[],version:"v3",frontMatter:{}},u={},c=[{value:"Compiling, linking, and binding",id:"compiling-linking-and-binding",level:2},{value:"Identifying files by name and directory tree",id:"identifying-files-by-name-and-directory-tree",level:2},{value:"Overriding implicit payload directories",id:"overriding-implicit-payload-directories",level:4},{value:"Preferred use",id:"preferred-use",level:4},{value:"Source directories",id:"source-directories",level:4},{value:"Identifying payload by source files",id:"identifying-payload-by-source-files",level:2},{value:"Preferred use",id:"preferred-use-1",level:4},{value:"Identifying payload via named binder paths",id:"identifying-payload-via-named-binder-paths",level:2},{value:"Preferred use",id:"preferred-use-2",level:4}],d={toc:c},f="wrapper";function h(e){var{components:t}=e,r=o(e,["components"]);return(0,n.kt)(f,a(function(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{},n=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(r).filter((function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable})))),n.forEach((function(t){i(e,t,r[t])}))}return e}({},d,r),{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"how-to-specify-source-files"},"How To: Specify source files"),(0,n.kt)("p",null,"WiX provides three ways of identifying a setup package's payload - the files\nthat are included in the setup and installed on the user's machine."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"By file name and directory tree."),(0,n.kt)("li",{parentName:"ul"},"By explicit source file."),(0,n.kt)("li",{parentName:"ul"},"Via named binder paths.")),(0,n.kt)("h2",{id:"compiling-linking-and-binding"},"Compiling, linking, and binding"),(0,n.kt)("p",null,"The WiX toolset models a typical C/C++ compiler in how authoring is built,\nwith a compiler that parses the WiX source authoring to object files and a\nlinker that combines the object files into an output. For WiX, the output is an\n.msi package, .msm merge module, or .wixlib library, which have a third phase:\nbinding payload files into the output. Light.exe includes both the linker and\nbinder."),(0,n.kt)("p",null,"Though WiX source authoring refers to payload files, the compiler never\nlooks at them; instead, only the binder does, when it creates cabinets\ncontaining them or copies them to an uncompressed layout."),(0,n.kt)("p",null,"You can provide the binder with one or more ",(0,n.kt)("em",{parentName:"p"},"binder input paths"),"\nit uses to look for files. It also looks for files relative to the current\nworking directory. Light.exe's -b switch and the BindInputPaths .wixproj\nproperty let you specify one or more binder input paths."),(0,n.kt)("p",null,"Binder input paths can also be prefixed with a ",(0,n.kt)("em",{parentName:"p"},"name")," which will\nappend that path to the identified binder input path bucket (unprefixed paths\nwill be added to the unnamed binder paths bucket). The bucket name must\nbe more than two characters long and be followed by an equal sign (",'"',"=",'"',"). See\nan example in the ",(0,n.kt)("em",{parentName:"p"},"Identifying payload via named binder paths")," section"),(0,n.kt)("h2",{id:"identifying-files-by-name-and-directory-tree"},"Identifying files by name and directory tree"),(0,n.kt)("p",null,"When you use the ",(0,n.kt)("a",{parentName:"p",href:"/wixtoolset/docs/v3/xsd/wix/file"},"File"),"/@Name\nattribute and don't use the File/@Source attribute, the compiler constructs an\nimplicit path to the file based on the file's parent component directory plus\nthe name you supply. So, for example, given the partial authoring"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-xml"},'    <Directory Id="TARGETDIR">\n      <Directory Name="foo">\n        <Directory Name="bar">\n          <Component>\n            <File Name="baz.txt" />\n')),(0,n.kt)("p",null,"the binder looks for a file ",(0,n.kt)("em",{parentName:"p"},"foo\\bar\\baz.txt")," in the unnamed binder\ninput paths."),(0,n.kt)("h4",{id:"overriding-implicit-payload-directories"},"Overriding implicit payload directories"),(0,n.kt)("p",null,"The ",(0,n.kt)("a",{parentName:"p",href:"/wixtoolset/docs/v3/xsd/wix/directoryref"},"FileSource"),"\nattribute for the ",(0,n.kt)("a",{parentName:"p",href:"/wixtoolset/docs/v3/xsd/wix/directory"},"Directory"),"\nand ",(0,n.kt)("a",{parentName:"p",href:"/wixtoolset/docs/v3/xsd/wix/directoryref"},"DirectoryRef"),"\nelements sets a new directory for files in that directory or any child\ndirectories. For example, given the partial authoring"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-xml"},'    <Directory Id="TARGETDIR">\n      <Directory Name="foo" FileSource="build\\retail\\x86">\n        <Directory Name="bar">\n          <Component>\n            <File Name="baz.txt" />\n')),(0,n.kt)("p",null,"the binder looks for a file ",(0,n.kt)("em",{parentName:"p"},"build\\retail\\x86\\bar\\baz.txt")," in the\nunnamed binder input paths."),(0,n.kt)("p",null,"The ",(0,n.kt)("a",{parentName:"p",href:"/wixtoolset/docs/v3/xsd/wix/directoryref"},"FileSource"),"\nattribute can use preprocessor variables or environment variables. If the value\nis an absolute path, the binder's unnamed input paths aren't used."),(0,n.kt)("h4",{id:"preferred-use"},"Preferred use"),(0,n.kt)("p",null,"If the build tree serving as your payload source is almost identical to the\ntree of your installed image and you have a moderate-to-deep directory tree,\nusing implicit paths will avoid repetition in your authoring."),(0,n.kt)("h4",{id:"source-directories"},"Source directories"),(0,n.kt)("p",null,"The Directory/@SourceName attribute controls both the name of the directory\nwhere Light.exe looks for files and the ",'"',"source directory",'"'," in the .msi package.\nUnless you also want to control the source directory, just use FileSource."),(0,n.kt)("h2",{id:"identifying-payload-by-source-files"},"Identifying payload by source files"),(0,n.kt)("p",null,"The File/@Source attribute is a path to the payload file. It can be an\nabsolute path or relative to any unnamed binder input path. If File/@Source is\npresent, it takes precedence over the implicit path created by Directory/@Name,\nDirectory/@FileSource, and File/@Name."),(0,n.kt)("p",null,"If you specify File/@Source, you can omit File/@Name because the compiler\nautomatically sets it to the filename portion of the source path."),(0,n.kt)("h4",{id:"preferred-use-1"},"Preferred use"),(0,n.kt)("p",null,"If the build tree serving as your payload source is different from the tree\nof your installed image, using File/@Source makes it easy to pick explicit\npaths than are different than the .msi package's directory tree. You can use\nmultiple unnamed binder input paths to shorten the File/@Source paths."),(0,n.kt)("p",null,"For example, the WiX setup .wixproj project points to the output tree for\nthe x86, x64, and ia64 platforms WiX supports and the WiX source tree. Unique\nfilenames can be referred to with just their filenames; files with the same\nname across platforms use relative paths."),(0,n.kt)("p",null,"See the WiX authoring in src","\\","Setup","\\","*.wxs for examples."),(0,n.kt)("h2",{id:"identifying-payload-via-named-binder-paths"},"Identifying payload via named binder paths"),(0,n.kt)("p",null,"This is similar in authoring style to ",'"',"Identifying payload by source files",'"',"\nwhile searching multiple paths like ",'"',"Identifying files by name and directory\ntree",'"',". As such, it is sort of a hybrid between the two."),(0,n.kt)("p",null,"Named bind paths uses the File/@Source path prefixed with a bindpath variable\nlike !(bindpath.",(0,n.kt)("em",{parentName:"p"},"bucketname"),"). As with the unnamed binder paths used when\nthe File/@Source is not present each path tagged with the same bucket name will\nbe tested until a matching file is found. If the resulting path is not an\nabsolute filepath, the unnamed binder file paths will be searched for each\nstring in the bucket."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},'<File Source="!(bindpath.foo)bar\\baz.txt" />\n<File Source="!(bindpath.bar)baz\\foo.txt" />\n\nlight -b foo=C:\\foo\\ -b bar=C:\\bar\\ -b foo=D:\\\n')),(0,n.kt)("p",null,"will look for the baz.txt file first at ",(0,n.kt)("em",{parentName:"p"},"C:\\foo\\bar\\baz.txt")," and then\nat ",(0,n.kt)("em",{parentName:"p"},"D:\\bar\\baz.txt"),", using the first one found, while looking for the foo.txt file at ",(0,n.kt)("em",{parentName:"p"},"C:\\bar\\baz\\foo.txt"),"; while"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},'<File Source="!(bindpath.foo)bar\\baz.txt" />\n<File Source="!(bindpath.bar)baz\\foo.txt" />\n\nlight -b foo=foo\\ -b bar=bar\\ -b foo=baz\\\n')),(0,n.kt)("p",null,"will search for the baz.txt file as if looking for two files having File/@Source values of ",(0,n.kt)("em",{parentName:"p"},"foo\\bar\\baz.txt")," and ",(0,n.kt)("em",{parentName:"p"},"baz\\bar\\baz.txt")," and will search for the foo.txt file as if the File/@Source was ",(0,n.kt)("em",{parentName:"p"},"bar\\baz\\foo.txt"),"."),(0,n.kt)("h4",{id:"preferred-use-2"},"Preferred use"),(0,n.kt)("p",null,"If the build tree serving as your payload source places the same category of\nfiles in several locations and you need to search those locations differently\nfor different categories of payload source files, using File/@Source with the\n",'"',"!(bindpath.",(0,n.kt)("em",{parentName:"p"},"bucketname"),")",'"'," prefix makes it easy to pick explicit groups\nof search paths. You can use multiple unnamed binder input paths to shorten the\nFile/@Source paths and/or the unnamed binder paths."),(0,n.kt)("p",null,"For example, a partial build system may separate binary and non-binary files\nto different paths stored on a network share while the local override build may\nnot have them separated. By prefixing the File/@Source values with the\nappropriate bindpath variable unique filenames can be referred to with just\ntheir filenames while files with the same name across platforms use relative\npaths."))}h.isMDXComponent=!0}}]);